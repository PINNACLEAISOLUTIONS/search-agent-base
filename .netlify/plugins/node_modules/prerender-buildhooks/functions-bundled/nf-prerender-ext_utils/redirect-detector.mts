// src/functions/utils/redirect-detector.mts
var RedirectDetector = class {
  page;
  clientRedirectUrl = null;
  landedUrl = null;
  captureRedirects = false;
  onFrameNavigated = null;
  constructor(page) {
    this.page = page;
  }
  /**
   * Navigate to a URL and detect any client-side redirects.
   *
   * @param url The URL to navigate to
   * @param options Navigation options
   * @param clientRedirectDetectionDelayMs How long to wait for client-side redirects after navigation
   */
  async navigate(url, options, clientRedirectDetectionDelayMs) {
    this.setupListener();
    const response = await this.page.goto(url, {
      waitUntil: "domcontentloaded",
      timeout: options.timeout
    });
    this.landedUrl = this.page.url();
    const hadServerRedirect = this.landedUrl !== url;
    if (hadServerRedirect) {
      console.log(`Server-side redirect: ${url} -> ${this.landedUrl}`);
    }
    this.captureRedirects = true;
    await new Promise((resolve) => setTimeout(resolve, clientRedirectDetectionDelayMs));
    return {
      response,
      landedUrl: this.landedUrl,
      clientRedirectUrl: this.clientRedirectUrl,
      hadServerRedirect
    };
  }
  /**
   * Check if a client-side redirect was detected.
   * Can be called after navigate() or when handling errors.
   */
  getClientRedirectUrl() {
    return this.clientRedirectUrl;
  }
  setupListener() {
    this.onFrameNavigated = (frame) => {
      if (!this.captureRedirects || frame !== this.page.mainFrame()) {
        return;
      }
      const newUrl = frame.url();
      if (newUrl === "about:blank" || newUrl === this.landedUrl) {
        return;
      }
      this.clientRedirectUrl = newUrl;
    };
    this.page.on("framenavigated", this.onFrameNavigated);
  }
};
export {
  RedirectDetector
};
