// src/functions/utils/browser.mts
import puppeteer from "puppeteer";
import chromium from "@sparticuz/chromium";
var isProduction = !process.env.NETLIFY_DEV;
var localShowBrowser = !isProduction && process.env.NETLIFY_PRERENDER_LOCAL_SHOW_BROWSER?.toLowerCase() === "true";
var _browser = null;
async function getBrowser() {
  if (_browser) {
    try {
      if (!_browser.connected) {
        throw new Error("Browser disconnected");
      }
      await Promise.race([
        _browser.pages(),
        new Promise(
          (_, reject) => setTimeout(() => reject(new Error("Health check timeout")), 2e3)
        )
      ]);
      console.log("Browser health check passed, reusing existing instance");
      return _browser;
    } catch (error) {
      console.log("Browser health check failed, recreating:", error?.message);
      try {
        await _browser.close();
      } catch (closeError) {
        console.log("Failed to close dead browser connection:", closeError?.message);
      }
      _browser = null;
    }
  }
  if (!_browser) {
    if (isProduction) {
      const executablePath = await chromium.executablePath();
      _browser = await puppeteer.launch({
        args: [...chromium.args],
        executablePath
      });
    } else {
      console.log("Local development environment detected, using bundled Chromium");
      _browser = await puppeteer.launch({
        headless: !localShowBrowser,
        args: ["--disable-dev-shm-usage"]
      });
    }
    console.log("New browser instance created");
  }
  return _browser;
}
async function closeBrowser() {
  if (_browser) {
    await _browser.close();
  }
  _browser = null;
}
async function clearStorage(cdpClient, page) {
  await page.evaluate(() => {
    localStorage.clear();
  });
  await cdpClient.send("Network.clearBrowserCookies");
}

// src/functions/utils/common-third-parties.mts
var COMMON_THIRD_PARTY_SKIP_LIST = [
  // Analytics & Tracking
  "2o7.net",
  "google-analytics.com",
  "googletagmanager.com",
  "amplitude.com",
  "mixpanel.com",
  "segment.com",
  "hotjar.com",
  "crazyegg.com",
  "luckyorange.com",
  "mouseflow.com",
  "fullstory.com",
  "clarity.ms",
  "newrelic.com",
  "nr-data.net",
  "datadoghq.com",
  "sentry.io",
  "quantummetric.com",
  "plausible.io",
  "heapanalytics.com",
  ".bugherd.com",
  ".bugsnag.com",
  ".pardot.com",
  "rudderstack.com",
  ".asortiz.com",
  ".mediavine.com",
  ".grow.me",
  // Advertising & Marketing, Payment, Monetization
  "adnxs.com",
  "adobedtm.com",
  "adroll.com",
  "ads-twitter.com",
  "adsafeprotected.com",
  "adsrvr.org",
  "adsymptotic.com",
  "advertising.com",
  "bing.com",
  "bizographics.com",
  "bkrtx.com",
  "bluekai.com",
  "casalemedia.com",
  "criteo.com",
  "criteo.net",
  "crwdcntrl.net",
  "dartsearch.net",
  "demdex.net",
  "doubleclick.net",
  "doubleverify.com",
  "everesttech.net",
  "facebook.com",
  "facebook.net",
  "fw-cdn.com",
  "googleadservices.com",
  "googlesyndication.com",
  "mathtag.com",
  "moatads.com",
  "monetate.net",
  "omtrdc.net",
  "openx.net",
  "optimizely.com",
  "outbrain.com",
  "pubmatic.com",
  "quantserve.com",
  "rubiconproject.com",
  "sc-static.net",
  "taboola.com",
  "tiqcdn.com",
  "visualwebsiteoptimizer.com",
  "yieldmanager.com",
  "mountain.com",
  "intentiq.com",
  "ad-delivery.net",
  ".ad.gt",
  "id5-sync.com",
  "nitropay.com",
  "braintreegateway.com",
  "pay.google.com",
  "play.google.com",
  "applepay.cdn-apple.com",
  "js.stripe.com",
  "www.ezojs.com",
  "ezoic.net",
  "chargebee.com",
  ".turn.com",
  "cdn.mxpnl.com",
  "onesignal.com",
  "paypal.com",
  "paypalobjects.com",
  ".adform.net",
  "razorpay.com",
  "formstack.com",
  // Social Media, Social Login
  "licdn.com",
  "snap.licdn.com",
  "pinimg.com",
  "pinterest.com",
  "redditstatic.com",
  "tiktok.com",
  "sharethis.com",
  "appleid.cdn-apple.com",
  "profitwell.com",
  "firstpromoter.com",
  "accounts.google.com",
  // Customer Support & Chat
  "crisp.chat",
  "driftt.com",
  "intercom.io",
  "intercomassets.com",
  "livechatinc.com",
  "tawk.to",
  "tidio.co",
  "zdassets.com",
  "zopim.com",
  "liveperson.net",
  // Forms & Surveys
  "hubspot.com",
  "hs-analytics.net",
  "hs-scripts.com",
  "hsforms.net",
  "qualified.com",
  "qualtrics.com",
  // Consent scripts, captchas, misc.
  ".iubenda.com",
  ".userway.org",
  "google.com/recaptcha",
  "cookielaw.org",
  "cookiepro.com",
  "cookiebot.com",
  "trustarc.com",
  "truste.com",
  "quantcast.com",
  "consensu.org",
  "usercentrics.eu",
  "osano.com",
  "privacy-center.org",
  "civiccomputing.com",
  "consentmanager.net",
  "privacymanager.io",
  "equalweb.com",
  "gatekeeperconsent.com",
  "cookie-script.com",
  "cdn-cookieyes.com",
  ".onetrust.com",
  // Media
  "www.youtube.com",
  "www.youtube-nocookie.com",
  ".live-video.net",
  // Netlify RUM
  "ingesteer.services-prod.nsvcs.net/rum_collection",
  // Real-time updates to data (these never stop...)
  "/google.firestore.v1beta1.Firestore/Listen/",
  "/google.firestore.v1.Firestore/Listen/",
  "events.launchdarkly.com"
];

// src/schema/prerender-configuration.ts
import { z } from "zod";
var urlSubstringValidator = z.string().optional().refine((value) => {
  if (!value) return true;
  const parts = value.split(",").map((part) => part.trim());
  return parts.every((part) => {
    const regexOnlyChars = /[[\](){}*+^$|\\]/;
    return !regexOnlyChars.test(part) && part.length > 0;
  });
}, {
  message: "Must be a comma-separated list of URL substrings (no regex characters like [], (), {}, *, +, ^, $, |, \\)"
});
var outputFormatValidator = z.string().default("html").refine((value) => {
  const validComponents = ["html", "tree", "report", "screenshot"];
  if (validComponents.includes(value)) {
    return true;
  }
  if (value.includes(",")) {
    const components = value.split(",").map((c) => c.trim());
    const uniqueComponents = new Set(components);
    return components.length === uniqueComponents.size && components.length > 0 && components.every((c) => validComponents.includes(c));
  }
  return false;
}, {
  message: "Must be 'html', 'tree', 'report', 'screenshot', or a comma-separated list like 'html,tree,report,screenshot'"
});
var prerenderConfigSchema = z.object({
  enabled: z.boolean().default(false),
  userAgent: z.string().default("Netlify Prerender Function"),
  disableCaching: z.boolean().default(false),
  skipVisualResources: z.boolean().default(true),
  skipThirdParty: z.enum(["none", "all", "common"]).default("common"),
  skipAlways: urlSubstringValidator,
  skipNever: urlSubstringValidator,
  detailedReporting: z.boolean().default(false),
  cacheMaxAgeHours: z.number().min(6).max(720).default(72),
  // 6 hours to 30 days, default 3 days
  cacheSwrHours: z.number().min(0).max(168).default(24),
  // 0 to 7 days, default 1 day
  outputFormat: outputFormatValidator,
  forceNewBrowser: z.boolean().default(false)
});
var optionalPrerenderConfigSchema = prerenderConfigSchema.omit({ enabled: true });
var optionalConfigDefaults = optionalPrerenderConfigSchema.parse({});
var BLOB_STORE_NAME = "netlify_prerender_extension";
var BLOB_OBJECT_NAME = "config.json";
function validateOptionalConfig(rawString) {
  try {
    if (!rawString || rawString.length === 0)
      return optionalConfigDefaults;
    const validatedConfig = optionalPrerenderConfigSchema.parse(JSON.parse(rawString));
    return validatedConfig;
  } catch (e) {
    console.error(`Error parsing optional config: [${rawString}], error:`, e);
    return optionalConfigDefaults;
  }
}
function optionalConfigWithoutDefaults(input) {
  function getObjectDifference(o1, o2) {
    const diff = {};
    for (const key in o2) {
      if (o1[key] !== o2[key]) {
        diff[key] = o2[key];
      }
    }
    return diff;
  }
  return getObjectDifference(optionalConfigDefaults, input);
}
var CACHE_TAG = "nf-prerender";

// src/functions/utils/prerender-config.mts
import { getStore } from "@netlify/blobs";
var THIRD_PARTY_SKIP_MODES = ["none", "all", "common"];
function parseOutputFormat(formatString) {
  if (formatString.includes(",")) {
    return formatString.split(",").map((c) => c.trim());
  }
  return [formatString];
}
async function createPrerenderConfig(req) {
  const isProduction2 = !process.env.NETLIFY_DEV;
  const allowRemoteHosts = "true" === process.env.NETLIFY_PRERENDER_ALLOW_REMOTE_HOSTS?.trim().toLowerCase();
  if (allowRemoteHosts) {
    console.warn(`==> NOTE: allowRemoteHosts IS ON`);
  }
  const rawDirectConfig = req.headers.get("X-Prerender-Direct-Config");
  const optionalConfig = await loadOptionalConfig(rawDirectConfig);
  const config2 = {
    directlyInvoked: rawDirectConfig !== null,
    /* Always read from dedicated env vars */
    isProduction: isProduction2,
    allowRemoteHosts,
    /* Optional config */
    userAgent: optionalConfig.userAgent,
    disableCaching: optionalConfig.disableCaching,
    cacheMaxAgeHours: optionalConfig.cacheMaxAgeHours,
    cacheSwrHours: optionalConfig.cacheSwrHours,
    enableDetailedReporting: optionalConfig.detailedReporting,
    skipVisualResources: optionalConfig.skipVisualResources,
    skipThirdParty: THIRD_PARTY_SKIP_MODES.includes(optionalConfig.skipThirdParty) ? optionalConfig.skipThirdParty : "common",
    skipAlways: optionalConfig.skipAlways?.split(",").filter(Boolean) || [],
    skipNever: optionalConfig.skipNever?.split(",").filter(Boolean) || [],
    outputFormats: parseOutputFormat(optionalConfig.outputFormat),
    forceNewBrowser: optionalConfig.forceNewBrowser,
    /* Currently hard-coded settings below */
    commonThirdPartySkipList: COMMON_THIRD_PARTY_SKIP_LIST,
    visualResourceTypes: ["image", "media", "font", "stylesheet"],
    skipSSE: true,
    waitAfterLastRequest: 500,
    pageDoneCheckInterval: 100,
    maxWaitTime: 15e3,
    inFlightReportAfterTime: 1e3,
    inFlightReportInterval: 1e3,
    navigationTimeout: 15e3,
    useAsyncCleanup: false
    // Currently disable this optimization, to avoid hard-to-debug async cleanup failures
  };
  return config2;
}
async function loadOptionalConfig(rawDirectConfig) {
  let result = optionalConfigDefaults;
  const rawConfigFromEnv = process.env.NETLIFY_PRERENDER_CONFIG;
  if (rawConfigFromEnv) {
    console.log("Using optional configuration from env var");
    result = validateOptionalConfig(rawConfigFromEnv);
  } else {
    try {
      const store = getStore(BLOB_STORE_NAME);
      const rawConfigFromBlob = await store.get(BLOB_OBJECT_NAME, { consistency: "strong" });
      if (rawConfigFromBlob) {
        console.log("Using optional configuration from blob storage");
        result = validateOptionalConfig(rawConfigFromBlob);
      }
    } catch (error) {
      console.error("Failed to load from blob storage", error);
    }
  }
  if (rawDirectConfig !== null) {
    const addedConfig = optionalConfigWithoutDefaults(validateOptionalConfig(rawDirectConfig));
    console.log("Function directly invoked, caching disabled");
    result = { ...result, ...addedConfig, disableCaching: true };
  }
  console.log("Optional config: ", JSON.stringify(result, null, 2).replace(/\n\s*/g, " "));
  return result;
}

// src/functions/utils/request-validation.mts
import { parse } from "psl";
import { isIPv4, isIPv6 } from "node:net";
var MAX_URL_LENGTH = 2048;
var MIN_TOKEN_LENGTH = 16;
function errorResult(message, status) {
  return {
    isValid: false,
    error: { message, status }
  };
}
function validateAuthToken(req) {
  const authToken = process.env.NETLIFY_PRERENDER_AUTH_TOKEN?.trim();
  if (!authToken || authToken.length < MIN_TOKEN_LENGTH) {
    const error = new Error(
      `NETLIFY_PRERENDER_AUTH_TOKEN is required and must be at least 16 bytes long. Current length: ${authToken?.length || 0} bytes`
    );
    console.error(error.message);
    return new Response("Configuration error", { status: 500 });
  }
  const providedToken = req.headers.get("X-Prerender-Token");
  if (!providedToken || providedToken.length < MIN_TOKEN_LENGTH || providedToken !== authToken) {
    const message = "Authentication token is " + (!providedToken ? "missing" : "invalid");
    return new Response(message, { status: 401 });
  }
  return null;
}
function validateTargetUrl(req, config2) {
  const requestUrl = new URL(req.url);
  const targetUrlParam = requestUrl.searchParams.get("url");
  if (!targetUrlParam)
    return errorResult("Missing url parameter", 400);
  if (targetUrlParam.length > MAX_URL_LENGTH)
    return errorResult("url too long", 400);
  let parsedTargetUrl;
  try {
    parsedTargetUrl = new URL(targetUrlParam);
  } catch {
    return errorResult(`Invalid URL format: ${targetUrlParam}`, 400);
  }
  const domain = extractDomain(parsedTargetUrl.hostname);
  if (!domain)
    return errorResult(`Invalid URL domain: ${targetUrlParam}`, 400);
  if (!config2.allowRemoteHosts) {
    if (parsedTargetUrl.host !== requestUrl.host || parsedTargetUrl.protocol !== requestUrl.protocol)
      return errorResult("Invalid target URL: must be same host & protocol", 403);
  }
  return {
    isValid: true,
    urlString: targetUrlParam,
    url: parsedTargetUrl,
    domain
  };
}
function extractDomain(hostname) {
  if (isIPv4(hostname) || isIPv6(hostname)) {
    return null;
  }
  if (hostname === "localhost") {
    return "localhost";
  }
  const result = parse(hostname);
  if (!("domain" in result) || !result.domain) {
    return null;
  }
  return result.domain;
}

// src/functions/utils/completion-detector.mts
var CompletionDetector = class {
  config;
  page;
  requestInterceptor;
  waitStart = 0;
  lastInFlightReportTime = 0;
  constructor(config2, page, requestInterceptor) {
    this.config = config2;
    this.page = page;
    this.requestInterceptor = requestInterceptor;
  }
  /**
   * Wait for page completion using configured strategies
   * Returns when either prerenderReady is true, network is idle, or timeout is reached
   */
  async waitForCompletion() {
    console.log("Waiting for window.prerenderReady or requests to settle...");
    this.waitStart = Date.now();
    this.lastInFlightReportTime = this.waitStart;
    while (true) {
      const result = await this.checkIfDone();
      if (result.completed) {
        return result;
      }
      await new Promise((resolve) => setTimeout(resolve, this.config.pageDoneCheckInterval));
    }
  }
  /**
   * Core completion detection logic
   * Evaluates prerenderReady flag and network activity
   */
  async checkIfDone() {
    const now = Date.now();
    const totalWaitTime = now - this.waitStart;
    if (totalWaitTime >= this.config.maxWaitTime) {
      return {
        completed: true,
        totalWaitTime,
        completionReason: "timeout"
      };
    }
    const currentPrerenderReady = await this.page.evaluate(() => {
      return typeof globalThis.prerenderReady === "boolean" ? globalThis.prerenderReady : null;
    });
    if (currentPrerenderReady !== null) {
      if (currentPrerenderReady === true) {
        return {
          completed: true,
          totalWaitTime,
          completionReason: "prerender-ready"
        };
      }
      return { completed: false, totalWaitTime, completionReason: "prerender-ready" };
    }
    const timeSinceLastRequest = now - this.requestInterceptor.getLastRequestTime();
    const numRequestsInFlight = this.requestInterceptor.getInFlightCount();
    const requestsSettled = numRequestsInFlight <= 0 && timeSinceLastRequest >= this.config.waitAfterLastRequest;
    if (numRequestsInFlight > 0 && totalWaitTime >= this.config.inFlightReportAfterTime) {
      if (now - this.lastInFlightReportTime > this.config.inFlightReportInterval) {
        const inflightUrls = this.requestInterceptor.getInFlightUrls();
        console.log(`In-flight requests after ${totalWaitTime}ms of wait: `, inflightUrls);
        this.lastInFlightReportTime = now;
      }
    }
    if (requestsSettled) {
      return {
        completed: true,
        totalWaitTime,
        completionReason: "network-idle"
      };
    }
    return { completed: false, totalWaitTime, completionReason: "network-idle" };
  }
};

// src/functions/utils/performance-timer.mts
var PerformanceTimer = class {
  startTime;
  phases = /* @__PURE__ */ new Map();
  constructor() {
    this.startTime = Date.now();
  }
  /**
   * Start timing a named phase
   */
  startPhase(phaseName) {
    this.phases.set(phaseName, { start: Date.now() });
  }
  /**
   * End timing a named phase and calculate duration
   */
  endPhase(phaseName) {
    const phase = this.phases.get(phaseName);
    if (!phase) {
      throw new Error(`Phase '${phaseName}' was not started`);
    }
    const end = Date.now();
    const duration = end - phase.start;
    this.phases.set(phaseName, {
      ...phase,
      end,
      duration
    });
    return duration;
  }
  /**
   * Get duration of a completed phase
   */
  getPhaseDuration(phaseName) {
    const phase = this.phases.get(phaseName);
    if (!phase?.duration) {
      throw new Error(`Phase '${phaseName}' is not completed`);
    }
    return phase.duration;
  }
  /**
   * Get total elapsed time since timer creation
   */
  getTotalElapsed() {
    return Date.now() - this.startTime;
  }
  /**
   * Get all phase durations as an object
   */
  getAllPhaseDurations() {
    const result = {};
    for (const [name, phase] of this.phases) {
      if (phase.duration !== void 0) {
        result[name] = phase.duration;
      }
    }
    return result;
  }
};

// src/functions/utils/request-interceptor.mts
var RequestInterceptor = class {
  config;
  pageDomain;
  requests = /* @__PURE__ */ new Map();
  inFlightRequests = /* @__PURE__ */ new Set();
  lastRequestTime = Date.now();
  navigationStartTime = Date.now();
  constructor(config2, pageDomain) {
    this.config = config2;
    this.pageDomain = pageDomain;
  }
  /**
   * Set up request interception on a Puppeteer page
   */
  async setup(page) {
    this.navigationStartTime = Date.now();
    await page.setRequestInterception(true);
    page.on("request", (request) => {
      this.handleRequest(request);
    });
    page.on("requestfinished", (request) => {
      this.handleRequestCompleted(request, "completed");
    });
    page.on("requestfailed", (request) => {
      this.handleRequestCompleted(request, "failed");
    });
  }
  handleRequest(request) {
    const url = request.url();
    const resourceType = request.resourceType();
    const reqId = request.id;
    const startTime = Date.now();
    const skipResult = this.shouldSkipRequest(url, resourceType);
    if (skipResult.shouldSkip) {
      this.requests.set(reqId, {
        id: reqId,
        url,
        resourceType,
        status: "skipped",
        skipReason: skipResult.reason,
        startTime,
        endTime: startTime,
        duration: 0
      });
      request.abort();
    } else {
      this.requests.set(reqId, {
        id: reqId,
        url,
        resourceType,
        status: "pending",
        startTime
      });
      if (!this.inFlightRequests.has(reqId)) {
        this.inFlightRequests.add(reqId);
        this.lastRequestTime = startTime;
      }
      request.continue();
    }
  }
  handleRequestCompleted(request, status) {
    const reqId = request.id;
    const endTime = Date.now();
    const record = this.requests.get(reqId);
    if (record) {
      if (record.status !== "skipped") {
        record.status = status;
        record.endTime = endTime;
        record.duration = endTime - record.startTime;
        this.requests.set(reqId, record);
      }
    }
    if (this.inFlightRequests.has(reqId)) {
      this.inFlightRequests.delete(reqId);
      this.lastRequestTime = endTime;
    }
  }
  shouldSkipRequest(url, resourceType) {
    for (const neverSkipItem of this.config.skipNever) {
      if (url.includes(neverSkipItem)) {
        return { shouldSkip: false };
      }
    }
    for (const alwaysSkipItem of this.config.skipAlways) {
      if (url.includes(alwaysSkipItem)) {
        return { shouldSkip: true, reason: "skip-always" };
      }
    }
    if (this.config.skipVisualResources) {
      if (this.config.visualResourceTypes.includes(resourceType)) {
        return { shouldSkip: true, reason: "visual-resource" };
      }
      try {
        const pathname = new URL(url).pathname;
        if (/\/favicon[^/]*$/.test(pathname) || pathname.endsWith(".png")) {
          return { shouldSkip: true, reason: "visual-resource" };
        }
      } catch {
      }
    }
    if (resourceType === "media") {
      return { shouldSkip: true, reason: "audio-video" };
    }
    if (this.config.skipSSE && resourceType === "eventsource") {
      return { shouldSkip: true, reason: "event-source" };
    }
    if (this.config.skipThirdParty !== "none") {
      try {
        const requestDomain = extractDomain(new URL(url).hostname);
        if (!requestDomain) {
          return { shouldSkip: true, reason: "invalid-domain" };
        }
        const isThirdParty = this.pageDomain !== requestDomain;
        if (isThirdParty) {
          if (this.config.skipThirdParty === "all") {
            return { shouldSkip: true, reason: "third-party-all" };
          } else if (this.config.skipThirdParty === "common") {
            const isCommonThirdParty = this.config.commonThirdPartySkipList.some(
              (pattern) => url.includes(pattern)
            );
            if (isCommonThirdParty) {
              return { shouldSkip: true, reason: "third-party-common" };
            }
          }
        }
      } catch {
        return { shouldSkip: true, reason: "url-parse-error" };
      }
    }
    return { shouldSkip: false };
  }
  /**
   * Get the number of requests currently in flight
   */
  getInFlightCount() {
    return this.inFlightRequests.size;
  }
  /**
   * Get the time of the last request activity
   */
  getLastRequestTime() {
    return this.lastRequestTime;
  }
  /**
   * Get URLs of currently in-flight requests (for debugging)
   */
  getInFlightUrls() {
    return Array.from(this.inFlightRequests).map((id) => this.requests.get(id)?.url || "unknown").map((url) => url.substring(0, 200));
  }
  /**
   * Get detailed statistics about all requests
   */
  getStats() {
    const records = Array.from(this.requests.values());
    const stats = {
      totalRequests: records.length,
      skippedRequests: records.filter((r) => r.status === "skipped").length,
      completedRequests: records.filter((r) => r.status === "completed").length,
      failedRequests: records.filter((r) => r.status === "failed").length,
      pendingRequests: records.filter((r) => r.status === "pending").length,
      requestsByType: {},
      requestsByDomain: {}
    };
    records.forEach((record) => {
      stats.requestsByType[record.resourceType] = (stats.requestsByType[record.resourceType] || 0) + 1;
    });
    records.forEach((record) => {
      try {
        const domain = extractDomain(new URL(record.url).hostname) || "unknown";
        stats.requestsByDomain[domain] = (stats.requestsByDomain[domain] || 0) + 1;
      } catch {
        stats.requestsByDomain["invalid"] = (stats.requestsByDomain["invalid"] || 0) + 1;
      }
    });
    return stats;
  }
  /**
   * Get all request records (for detailed reporting)
   */
  getAllRequests() {
    return Array.from(this.requests.values());
  }
  /**
   * Get all request records with timestamps relative to navigation start
   */
  getAllRequestsWithRelativeTimestamps() {
    return Array.from(this.requests.values()).map((record) => ({
      ...record,
      startTime: record.startTime - this.navigationStartTime,
      endTime: record.endTime ? record.endTime - this.navigationStartTime : void 0
    }));
  }
  /**
   * Generate a detailed report of all requests in table format
   */
  generateReport() {
    const stats = this.getStats();
    const records = this.getAllRequests().sort((a, b) => a.startTime - b.startTime);
    let report = `REQUEST INTERCEPTION REPORT
`;
    report += `============================

`;
    report += `SUMMARY:
`;
    report += `- Total requests: ${stats.totalRequests}
`;
    report += `- Completed: ${stats.completedRequests}
`;
    report += `- Failed: ${stats.failedRequests}
`;
    report += `- Skipped: ${stats.skippedRequests}
`;
    report += `- Pending: ${stats.pendingRequests}

`;
    if (records.length === 0) {
      report += `No requests recorded.
`;
      return report;
    }
    report += `REQUEST DETAILS:
`;
    report += `${"Status".padEnd(25)} ${"Type".padEnd(12)} ${"Start(ms)".padEnd(10)} ${"End(ms)".padEnd(10)} URL
`;
    report += `${"-".repeat(25)} ${"-".repeat(12)} ${"-".repeat(10)} ${"-".repeat(10)} ${"-".repeat(50)}
`;
    records.forEach((record) => {
      const relativeStartTime = record.startTime - this.navigationStartTime;
      const relativeEndTime = record.endTime ? record.endTime - this.navigationStartTime : null;
      let statusColumn = record.status;
      if (record.status === "skipped" && record.skipReason) {
        statusColumn = `skipped (${record.skipReason})`;
      }
      const statusStr = statusColumn.padEnd(25);
      const typeStr = record.resourceType.padEnd(12);
      const startStr = relativeStartTime.toString().padEnd(10);
      const endStr = relativeEndTime !== null ? relativeEndTime.toString().padEnd(10) : "".padEnd(10);
      let url = record.url;
      if (url.length > 120) {
        url = url.substring(0, 117) + "...";
      }
      report += `${statusStr} ${typeStr} ${startStr} ${endStr} ${url}
`;
    });
    return report;
  }
  /**
   * Generate status breakdown string for a set of records
   */
  getStatusBreakdown(records) {
    const statusCounts = {
      completed: records.filter((r) => r.status === "completed").length,
      failed: records.filter((r) => r.status === "failed").length,
      skipped: records.filter((r) => r.status === "skipped").length,
      pending: records.filter((r) => r.status === "pending").length
    };
    const parts = [];
    if (statusCounts.completed > 0) parts.push(`${statusCounts.completed} completed`);
    if (statusCounts.failed > 0) parts.push(`${statusCounts.failed} failed`);
    if (statusCounts.skipped > 0) parts.push(`${statusCounts.skipped} skipped`);
    if (statusCounts.pending > 0) parts.push(`${statusCounts.pending} pending`);
    return parts.join(", ") || "0";
  }
};

// src/functions/utils/redirect-detector.mts
var RedirectDetector = class {
  page;
  clientRedirectUrl = null;
  landedUrl = null;
  captureRedirects = false;
  onFrameNavigated = null;
  constructor(page) {
    this.page = page;
  }
  /**
   * Navigate to a URL and detect any client-side redirects.
   *
   * @param url The URL to navigate to
   * @param options Navigation options
   * @param clientRedirectDetectionDelayMs How long to wait for client-side redirects after navigation
   */
  async navigate(url, options, clientRedirectDetectionDelayMs) {
    this.setupListener();
    const response = await this.page.goto(url, {
      waitUntil: "domcontentloaded",
      timeout: options.timeout
    });
    this.landedUrl = this.page.url();
    const hadServerRedirect = this.landedUrl !== url;
    if (hadServerRedirect) {
      console.log(`Server-side redirect: ${url} -> ${this.landedUrl}`);
    }
    this.captureRedirects = true;
    await new Promise((resolve) => setTimeout(resolve, clientRedirectDetectionDelayMs));
    return {
      response,
      landedUrl: this.landedUrl,
      clientRedirectUrl: this.clientRedirectUrl,
      hadServerRedirect
    };
  }
  /**
   * Check if a client-side redirect was detected.
   * Can be called after navigate() or when handling errors.
   */
  getClientRedirectUrl() {
    return this.clientRedirectUrl;
  }
  setupListener() {
    this.onFrameNavigated = (frame) => {
      if (!this.captureRedirects || frame !== this.page.mainFrame()) {
        return;
      }
      const newUrl = frame.url();
      if (newUrl === "about:blank" || newUrl === this.landedUrl) {
        return;
      }
      this.clientRedirectUrl = newUrl;
    };
    this.page.on("framenavigated", this.onFrameNavigated);
  }
};

// src/functions/utils/prerender-error.mts
var PrerenderError = class _PrerenderError extends Error {
  kind;
  constructor(kind) {
    super(_PrerenderError.getMessage(kind));
    this.kind = kind;
    this.name = "PrerenderError";
  }
  static getMessage(kind) {
    const base = "Prerender failed.";
    switch (kind.type) {
      case "navigation_failed":
        return `${base} Navigation returned no response.`;
      case "page_status":
        return `${base} The page returned HTTP status ${kind.status}.`;
      case "invalid_content_type":
        return `${base} The page content type "${kind.contentType}" is not HTML.`;
      case "cache_control_private":
        return `${base} The page returns a cache-control header marking it as private or no-store. For security reasons, pre-rendering does not support non-public content.`;
      case "accessibility_snapshot_failed":
        return `${base} Failed to get accessibility snapshot from browser.`;
      case "navigation_timeout":
        return `${base} If your web page is functioning normally, it might be too heavy for this basic pre-rendering service to process.`;
      case "context_destroyed":
        return `${base} Your web page seems to use client-side redirects, which pre-rendering does not support.`;
      case "unknown":
        return base;
    }
  }
  /**
   * Returns the HTTP status code appropriate for this error.
   */
  getHttpStatus() {
    switch (this.kind.type) {
      case "page_status":
        return this.kind.status;
      default:
        return 500;
    }
  }
};
function wrapError(error) {
  if (error instanceof PrerenderError) {
    return error;
  }
  const message = error instanceof Error ? error.message : String(error);
  if (message === "Execution context was destroyed, most likely because of a navigation.") {
    return new PrerenderError({ type: "context_destroyed" });
  }
  const timeoutMatch = message.match(/^Navigation timeout of (\d+) ms exceeded$/);
  if (timeoutMatch) {
    return new PrerenderError({ type: "navigation_timeout", timeoutMs: parseInt(timeoutMatch[1], 10) });
  }
  return new PrerenderError({ type: "unknown", originalMessage: message });
}

// src/functions/prerender.mts
var CLIENT_REDIRECT_DETECTION_DELAY_MS = 150;
var prerender_default = async (req, context) => {
  const authError = validateAuthToken(req);
  if (authError) {
    return authError;
  }
  const isPingRequest = req.headers.get("X-Prerender-Ping");
  if (isPingRequest) {
    console.log("Ping request received");
    await getBrowser();
    return new Response("pong");
  }
  const timer = new PerformanceTimer();
  let targetUrlInfo = null;
  let redirectDetector = null;
  timer.startPhase("getConfig");
  const config2 = await createPrerenderConfig(req);
  timer.endPhase("getConfig");
  try {
    targetUrlInfo = validateTargetUrl(req, config2);
    if (!targetUrlInfo.isValid) {
      return new Response(targetUrlInfo.error.message, { status: targetUrlInfo.error.status });
    } else {
      console.log(`Got request to prerender this URL: ${targetUrlInfo.urlString}`);
    }
    console.log(`Getting browser instance...`);
    timer.startPhase("getBrowser");
    const browserInstance = await getBrowser();
    const page = await browserInstance.newPage();
    timer.endPhase("getBrowser");
    timer.startPhase("setupPage");
    const requestInterceptor = new RequestInterceptor(config2, targetUrlInfo.domain);
    await requestInterceptor.setup(page);
    await page.setViewport({ width: 1440, height: 900 });
    await page.setUserAgent({ userAgent: config2.userAgent });
    await page.setCacheEnabled(false);
    const cdpClient = await page.createCDPSession();
    await cdpClient.send("ServiceWorker.disable");
    await cdpClient.send("Network.setBypassServiceWorker", { bypass: true });
    await page.evaluateOnNewDocument(() => {
      globalThis.__PRERENDER__ = true;
    });
    timer.endPhase("setupPage");
    timer.startPhase("navigation");
    console.log(`Navigating to ${targetUrlInfo.urlString}...`);
    redirectDetector = new RedirectDetector(page);
    const navResult = await redirectDetector.navigate(
      targetUrlInfo.urlString,
      { timeout: config2.navigationTimeout },
      CLIENT_REDIRECT_DETECTION_DELAY_MS
    );
    timer.endPhase("navigation");
    if (navResult.clientRedirectUrl) {
      await page.close();
      return buildRedirectResponse(navResult.clientRedirectUrl, timer.getTotalElapsed(), targetUrlInfo.urlString);
    }
    if (navResult.hadServerRedirect && hasNonHtmlFileExtension(navResult.landedUrl)) {
      console.log(`Server-side redirect to non-HTML file: ${targetUrlInfo.urlString} -> ${navResult.landedUrl}`);
      await page.close();
      return buildRedirectResponse(navResult.landedUrl, timer.getTotalElapsed(), targetUrlInfo.urlString);
    }
    const originalResponse = navResult.response;
    if (!originalResponse)
      throw new PrerenderError({ type: "navigation_failed" });
    const originalStatus = originalResponse.status();
    if (originalStatus !== 200)
      throw new PrerenderError({ type: "page_status", status: originalStatus, statusText: originalResponse.statusText() });
    const originalContentType = originalResponse.headers()["content-type"];
    if (originalContentType && !(originalContentType === "text/html" || originalContentType.startsWith("text/html;")))
      throw new PrerenderError({ type: "invalid_content_type", contentType: originalContentType });
    if (hasCacheControlDirective(originalResponse.headers(), ["private", "no-store"]))
      throw new PrerenderError({ type: "cache_control_private" });
    timer.startPhase("completion");
    const detector = new CompletionDetector(config2, page, requestInterceptor);
    const completionResult = await detector.waitForCompletion();
    timer.endPhase("completion");
    const stats = requestInterceptor.getStats();
    const reportData = config2.outputFormats.includes("report") ? {
      summary: stats,
      requests: requestInterceptor.getAllRequestsWithRelativeTimestamps(),
      completionReason: completionResult.completionReason
    } : null;
    timer.startPhase("extraction");
    const outputData = {};
    for (const component of config2.outputFormats) {
      switch (component) {
        case "html":
          outputData.html = await page.content();
          break;
        case "tree": {
          const a11ySnapshot = await page.accessibility.snapshot({ includeIframes: true });
          if (!a11ySnapshot)
            throw new PrerenderError({ type: "accessibility_snapshot_failed" });
          outputData.tree = formatAccessibilityTree(a11ySnapshot);
          break;
        }
        case "report":
          outputData.report = reportData;
          break;
        case "screenshot": {
          const screenshotBuffer = await page.screenshot({
            type: "webp",
            fullPage: true
          });
          outputData.screenshot = Buffer.from(screenshotBuffer).toString("base64");
          break;
        }
      }
    }
    timer.endPhase("extraction");
    const isCompoundOutput = config2.outputFormats.length > 1;
    const singleComponent = config2.outputFormats[0];
    const needsJsonEncoding = isCompoundOutput || singleComponent === "report";
    const responseBody = needsJsonEncoding ? JSON.stringify(outputData) : outputData[singleComponent];
    const responseSize = Buffer.byteLength(responseBody, "utf8");
    timer.startPhase("close");
    await clearStorage(cdpClient, page);
    await page.close();
    if (config2.forceNewBrowser) {
      console.log("Closing browser");
      await closeBrowser();
    }
    timer.endPhase("close");
    logSuccess(targetUrlInfo.urlString, timer, stats, completionResult.completionReason, responseSize);
    if (config2.enableDetailedReporting) {
      console.log("\n" + requestInterceptor.generateReport());
    }
    return buildSuccessResponse(originalResponse, responseBody, config2, needsJsonEncoding);
  } catch (caughtError) {
    const error = wrapError(caughtError);
    const targetUrl = targetUrlInfo?.urlString || req.url;
    const clientRedirectUrl = redirectDetector?.getClientRedirectUrl();
    if (error.kind.type === "context_destroyed" && clientRedirectUrl) {
      console.log(`Client-side redirect detected (via context destroyed): ${targetUrl} -> ${clientRedirectUrl}`);
      await closeBrowser();
      return buildRedirectResponse(clientRedirectUrl, timer.getTotalElapsed(), targetUrl);
    }
    await closeBrowser();
    return buildErrorResponse(error, timer.getTotalElapsed(), targetUrl);
  }
};
function buildSuccessResponse(originalResponse, responseBody, config2, needsJsonEncoding) {
  const originalHeaders = originalResponse.headers();
  const origCacheTags = originalHeaders["cache-tag"], origVary = originalHeaders["vary"], origNetlifyVary = originalHeaders["netlify-vary"];
  const varyByAll = origVary?.trim() === "*";
  let contentType;
  if (needsJsonEncoding) {
    contentType = "application/json; charset=utf-8";
  } else {
    const singleComponent = config2.outputFormats[0];
    if (singleComponent === "html") {
      contentType = "text/html; charset=utf-8";
    } else {
      contentType = "text/plain; charset=utf-8";
    }
  }
  const headers = {
    "Content-Type": contentType,
    "X-Prerendered": "true",
    "X-Prerender-Timestamp": (/* @__PURE__ */ new Date()).toISOString(),
    "X-Content-Type-Options": "nosniff",
    "X-Frame-Options": "SAMEORIGIN"
  };
  if (config2.disableCaching || varyByAll) {
    headers["Cache-Control"] = "no-cache";
  } else {
    const maxAgeSeconds = config2.cacheMaxAgeHours * 3600;
    const swrSeconds = config2.cacheSwrHours * 3600;
    let cacheControl = `public, max-age=${maxAgeSeconds}`;
    if (swrSeconds > 0) {
      cacheControl += `, stale-while-revalidate=${swrSeconds}`;
    }
    cacheControl += ", durable";
    headers["Netlify-CDN-Cache-Control"] = cacheControl;
    headers["Cache-Control"] = "public, max-age=0, must-revalidate";
    let cacheTags = CACHE_TAG;
    if (origCacheTags) {
      cacheTags = cacheTags + "," + origCacheTags;
    }
    headers["Cache-Tag"] = cacheTags;
    if (origVary)
      headers["Vary"] = origVary;
    if (origNetlifyVary)
      headers["Netlify-Vary"] = origNetlifyVary;
  }
  return new Response(responseBody, { status: 200, headers });
}
function buildErrorResponse(error, elapsedTime, targetUrl) {
  console.error(`Failed for ${targetUrl} after ${elapsedTime}ms: [${error.kind.type}] ${error.message}`);
  return new Response(error.message, { status: error.getHttpStatus() });
}
function buildRedirectResponse(redirectUrl, elapsedTime, originalUrl) {
  console.log(`REDIRECT: ${originalUrl} -> ${redirectUrl} | ${elapsedTime}ms`);
  return new Response(null, {
    status: 302,
    headers: {
      "Location": redirectUrl,
      "X-Prerendered": "true",
      "X-Prerender-Redirect": "true",
      "Cache-Control": "no-cache"
    }
  });
}
function hasNonHtmlFileExtension(url) {
  try {
    const pathname = new URL(url).pathname;
    const match = pathname.match(/\.([a-zA-Z0-9]+)$/);
    if (!match) return false;
    const ext = match[1].toLowerCase();
    return ext !== "htm" && ext !== "html";
  } catch {
    return false;
  }
}
function formatAccessibilityTree(node, depth = 0) {
  let result = " ".repeat(depth * 2) + `${node.role} "${node.name || ""}"
`;
  if (node.children) {
    for (const child of node.children) {
      result += formatAccessibilityTree(child, depth + 1);
    }
  }
  return result;
}
function logSuccess(targetUrl, timer, stats, completionReason, htmlSize) {
  const phases = timer.getAllPhaseDurations();
  const phaseTimings = Object.entries(phases).map(([name, duration]) => `${duration}ms ${name}`).join(", ");
  console.log(
    `SUCCESS: ${targetUrl} | ${timer.getTotalElapsed()}ms total (${phaseTimings}) | 200 status | ${htmlSize}B HTML | ${stats.skippedRequests} requests skipped, ${stats.completedRequests} completed, ${stats.failedRequests} failed | completed via ${completionReason}`
  );
}
function hasCacheControlDirective(headers, directives) {
  const CACHE_CONTROL_HEADERS = ["cache-control", "cdn-cache-control", "netlify-cdn-cache-control"];
  const directivesArr = Array.isArray(directives) ? directives : [directives];
  return CACHE_CONTROL_HEADERS.some((k) => {
    const headerValue = headers[k];
    if (!headerValue) return false;
    const parts = headerValue.toLowerCase().split(",").map((e) => {
      return e.trim();
    });
    return directivesArr.some(
      (directive) => {
        return parts.includes(directive);
      }
    );
  });
}
var config = {
  path: "/netlify-prerender-function",
  generator: "netlify-prerender-extension",
  name: "Netlify Prerender"
  // name attribute is valid, but not yet exposed in type.
};
export {
  config,
  prerender_default as default,
  formatAccessibilityTree
};
