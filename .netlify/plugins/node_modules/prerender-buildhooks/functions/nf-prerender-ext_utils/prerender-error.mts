// src/functions/utils/prerender-error.mts
var PrerenderError = class _PrerenderError extends Error {
  kind;
  constructor(kind) {
    super(_PrerenderError.getMessage(kind));
    this.kind = kind;
    this.name = "PrerenderError";
  }
  static getMessage(kind) {
    const base = "Prerender failed.";
    switch (kind.type) {
      case "navigation_failed":
        return `${base} Navigation returned no response.`;
      case "page_status":
        return `${base} The page returned HTTP status ${kind.status}.`;
      case "invalid_content_type":
        return `${base} The page content type "${kind.contentType}" is not HTML.`;
      case "cache_control_private":
        return `${base} The page returns a cache-control header marking it as private or no-store. For security reasons, pre-rendering does not support non-public content.`;
      case "accessibility_snapshot_failed":
        return `${base} Failed to get accessibility snapshot from browser.`;
      case "navigation_timeout":
        return `${base} If your web page is functioning normally, it might be too heavy for this basic pre-rendering service to process.`;
      case "context_destroyed":
        return `${base} Your web page seems to use client-side redirects, which pre-rendering does not support.`;
      case "unknown":
        return base;
    }
  }
  /**
   * Returns the HTTP status code appropriate for this error.
   */
  getHttpStatus() {
    switch (this.kind.type) {
      case "page_status":
        return this.kind.status;
      default:
        return 500;
    }
  }
};
function wrapError(error) {
  if (error instanceof PrerenderError) {
    return error;
  }
  const message = error instanceof Error ? error.message : String(error);
  if (message === "Execution context was destroyed, most likely because of a navigation.") {
    return new PrerenderError({ type: "context_destroyed" });
  }
  const timeoutMatch = message.match(/^Navigation timeout of (\d+) ms exceeded$/);
  if (timeoutMatch) {
    return new PrerenderError({ type: "navigation_timeout", timeoutMs: parseInt(timeoutMatch[1], 10) });
  }
  return new PrerenderError({ type: "unknown", originalMessage: message });
}
export {
  PrerenderError,
  wrapError
};
