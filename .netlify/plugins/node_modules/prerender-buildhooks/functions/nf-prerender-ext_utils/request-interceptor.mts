// src/functions/utils/request-validation.mts
import { parse } from "psl";
import { isIPv4, isIPv6 } from "node:net";
function extractDomain(hostname) {
  if (isIPv4(hostname) || isIPv6(hostname)) {
    return null;
  }
  if (hostname === "localhost") {
    return "localhost";
  }
  const result = parse(hostname);
  if (!("domain" in result) || !result.domain) {
    return null;
  }
  return result.domain;
}

// src/functions/utils/request-interceptor.mts
var RequestInterceptor = class {
  config;
  pageDomain;
  requests = /* @__PURE__ */ new Map();
  inFlightRequests = /* @__PURE__ */ new Set();
  lastRequestTime = Date.now();
  navigationStartTime = Date.now();
  constructor(config, pageDomain) {
    this.config = config;
    this.pageDomain = pageDomain;
  }
  /**
   * Set up request interception on a Puppeteer page
   */
  async setup(page) {
    this.navigationStartTime = Date.now();
    await page.setRequestInterception(true);
    page.on("request", (request) => {
      this.handleRequest(request);
    });
    page.on("requestfinished", (request) => {
      this.handleRequestCompleted(request, "completed");
    });
    page.on("requestfailed", (request) => {
      this.handleRequestCompleted(request, "failed");
    });
  }
  handleRequest(request) {
    const url = request.url();
    const resourceType = request.resourceType();
    const reqId = request.id;
    const startTime = Date.now();
    const skipResult = this.shouldSkipRequest(url, resourceType);
    if (skipResult.shouldSkip) {
      this.requests.set(reqId, {
        id: reqId,
        url,
        resourceType,
        status: "skipped",
        skipReason: skipResult.reason,
        startTime,
        endTime: startTime,
        duration: 0
      });
      request.abort();
    } else {
      this.requests.set(reqId, {
        id: reqId,
        url,
        resourceType,
        status: "pending",
        startTime
      });
      if (!this.inFlightRequests.has(reqId)) {
        this.inFlightRequests.add(reqId);
        this.lastRequestTime = startTime;
      }
      request.continue();
    }
  }
  handleRequestCompleted(request, status) {
    const reqId = request.id;
    const endTime = Date.now();
    const record = this.requests.get(reqId);
    if (record) {
      if (record.status !== "skipped") {
        record.status = status;
        record.endTime = endTime;
        record.duration = endTime - record.startTime;
        this.requests.set(reqId, record);
      }
    }
    if (this.inFlightRequests.has(reqId)) {
      this.inFlightRequests.delete(reqId);
      this.lastRequestTime = endTime;
    }
  }
  shouldSkipRequest(url, resourceType) {
    for (const neverSkipItem of this.config.skipNever) {
      if (url.includes(neverSkipItem)) {
        return { shouldSkip: false };
      }
    }
    for (const alwaysSkipItem of this.config.skipAlways) {
      if (url.includes(alwaysSkipItem)) {
        return { shouldSkip: true, reason: "skip-always" };
      }
    }
    if (this.config.skipVisualResources) {
      if (this.config.visualResourceTypes.includes(resourceType)) {
        return { shouldSkip: true, reason: "visual-resource" };
      }
      try {
        const pathname = new URL(url).pathname;
        if (/\/favicon[^/]*$/.test(pathname) || pathname.endsWith(".png")) {
          return { shouldSkip: true, reason: "visual-resource" };
        }
      } catch {
      }
    }
    if (resourceType === "media") {
      return { shouldSkip: true, reason: "audio-video" };
    }
    if (this.config.skipSSE && resourceType === "eventsource") {
      return { shouldSkip: true, reason: "event-source" };
    }
    if (this.config.skipThirdParty !== "none") {
      try {
        const requestDomain = extractDomain(new URL(url).hostname);
        if (!requestDomain) {
          return { shouldSkip: true, reason: "invalid-domain" };
        }
        const isThirdParty = this.pageDomain !== requestDomain;
        if (isThirdParty) {
          if (this.config.skipThirdParty === "all") {
            return { shouldSkip: true, reason: "third-party-all" };
          } else if (this.config.skipThirdParty === "common") {
            const isCommonThirdParty = this.config.commonThirdPartySkipList.some(
              (pattern) => url.includes(pattern)
            );
            if (isCommonThirdParty) {
              return { shouldSkip: true, reason: "third-party-common" };
            }
          }
        }
      } catch {
        return { shouldSkip: true, reason: "url-parse-error" };
      }
    }
    return { shouldSkip: false };
  }
  /**
   * Get the number of requests currently in flight
   */
  getInFlightCount() {
    return this.inFlightRequests.size;
  }
  /**
   * Get the time of the last request activity
   */
  getLastRequestTime() {
    return this.lastRequestTime;
  }
  /**
   * Get URLs of currently in-flight requests (for debugging)
   */
  getInFlightUrls() {
    return Array.from(this.inFlightRequests).map((id) => this.requests.get(id)?.url || "unknown").map((url) => url.substring(0, 200));
  }
  /**
   * Get detailed statistics about all requests
   */
  getStats() {
    const records = Array.from(this.requests.values());
    const stats = {
      totalRequests: records.length,
      skippedRequests: records.filter((r) => r.status === "skipped").length,
      completedRequests: records.filter((r) => r.status === "completed").length,
      failedRequests: records.filter((r) => r.status === "failed").length,
      pendingRequests: records.filter((r) => r.status === "pending").length,
      requestsByType: {},
      requestsByDomain: {}
    };
    records.forEach((record) => {
      stats.requestsByType[record.resourceType] = (stats.requestsByType[record.resourceType] || 0) + 1;
    });
    records.forEach((record) => {
      try {
        const domain = extractDomain(new URL(record.url).hostname) || "unknown";
        stats.requestsByDomain[domain] = (stats.requestsByDomain[domain] || 0) + 1;
      } catch {
        stats.requestsByDomain["invalid"] = (stats.requestsByDomain["invalid"] || 0) + 1;
      }
    });
    return stats;
  }
  /**
   * Get all request records (for detailed reporting)
   */
  getAllRequests() {
    return Array.from(this.requests.values());
  }
  /**
   * Get all request records with timestamps relative to navigation start
   */
  getAllRequestsWithRelativeTimestamps() {
    return Array.from(this.requests.values()).map((record) => ({
      ...record,
      startTime: record.startTime - this.navigationStartTime,
      endTime: record.endTime ? record.endTime - this.navigationStartTime : void 0
    }));
  }
  /**
   * Generate a detailed report of all requests in table format
   */
  generateReport() {
    const stats = this.getStats();
    const records = this.getAllRequests().sort((a, b) => a.startTime - b.startTime);
    let report = `REQUEST INTERCEPTION REPORT
`;
    report += `============================

`;
    report += `SUMMARY:
`;
    report += `- Total requests: ${stats.totalRequests}
`;
    report += `- Completed: ${stats.completedRequests}
`;
    report += `- Failed: ${stats.failedRequests}
`;
    report += `- Skipped: ${stats.skippedRequests}
`;
    report += `- Pending: ${stats.pendingRequests}

`;
    if (records.length === 0) {
      report += `No requests recorded.
`;
      return report;
    }
    report += `REQUEST DETAILS:
`;
    report += `${"Status".padEnd(25)} ${"Type".padEnd(12)} ${"Start(ms)".padEnd(10)} ${"End(ms)".padEnd(10)} URL
`;
    report += `${"-".repeat(25)} ${"-".repeat(12)} ${"-".repeat(10)} ${"-".repeat(10)} ${"-".repeat(50)}
`;
    records.forEach((record) => {
      const relativeStartTime = record.startTime - this.navigationStartTime;
      const relativeEndTime = record.endTime ? record.endTime - this.navigationStartTime : null;
      let statusColumn = record.status;
      if (record.status === "skipped" && record.skipReason) {
        statusColumn = `skipped (${record.skipReason})`;
      }
      const statusStr = statusColumn.padEnd(25);
      const typeStr = record.resourceType.padEnd(12);
      const startStr = relativeStartTime.toString().padEnd(10);
      const endStr = relativeEndTime !== null ? relativeEndTime.toString().padEnd(10) : "".padEnd(10);
      let url = record.url;
      if (url.length > 120) {
        url = url.substring(0, 117) + "...";
      }
      report += `${statusStr} ${typeStr} ${startStr} ${endStr} ${url}
`;
    });
    return report;
  }
  /**
   * Generate status breakdown string for a set of records
   */
  getStatusBreakdown(records) {
    const statusCounts = {
      completed: records.filter((r) => r.status === "completed").length,
      failed: records.filter((r) => r.status === "failed").length,
      skipped: records.filter((r) => r.status === "skipped").length,
      pending: records.filter((r) => r.status === "pending").length
    };
    const parts = [];
    if (statusCounts.completed > 0) parts.push(`${statusCounts.completed} completed`);
    if (statusCounts.failed > 0) parts.push(`${statusCounts.failed} failed`);
    if (statusCounts.skipped > 0) parts.push(`${statusCounts.skipped} skipped`);
    if (statusCounts.pending > 0) parts.push(`${statusCounts.pending} pending`);
    return parts.join(", ") || "0";
  }
};
export {
  RequestInterceptor
};
